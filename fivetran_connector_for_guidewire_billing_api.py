# -*- coding: utf-8 -*-
"""Fivetran Connector for Guidewire Billing API

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DlaIqjsbmKkgfiPm7CDJiT27RRa4pyzQ
"""

from datetime import datetime
import requests as rq
from fivetran_connector_sdk import Connector
from fivetran_connector_sdk import Logging as log
from fivetran_connector_sdk import Operations as op

# Configuration Keys (Important: Use Fivetran UI for secure storage)
GUIDEWIRE_BASE_URL = "guidewire_base_url"  # e.g., "http://your-guidewire-instance/billing/rest/v1"
GUIDEWIRE_USERNAME = "guidewire_username"
GUIDEWIRE_PASSWORD = "guidewire_password"
GUIDEWIRE_API_VERSION = "guidewire_api_version" # e.g., "v1", "v2"

def schema(configuration: dict):
    """
    Defines the schema for billing plan data.  Adjust this based on the
    actual structure of the Guidewire Billing API response.  This example
    schema is based on the documentation, but you'll need to verify it.
    """
    return [
        {
            "table": "billing_plans",
            "primary_key": ["id"],
            "columns": {
                "id": "STRING",  #  The ID of the billing plan.
                "plan_name": "STRING",  # The name of the billing plan.
                "description": "STRING",  # A description of the billing plan.
                "start_date": "UTC_DATETIME",  # The start date of the billing plan.
                "end_date": "UTC_DATETIME",  # The end date of the billing plan.
                "status": "STRING", # Status of the billing plan
                "create_time": "UTC_DATETIME",  # When plan was created
                "update_time": "UTC_DATETIME",  # When plan was last updated.
                "account_id": "STRING", # ID of the account
                # Add more columns as needed based on the API response and your requirements
            },
        }
    ]


def str2dt(incoming: str) -> datetime:
    """Helper function to convert string to datetime (adjust format as needed)."""
    try:
        # Attempt to parse the datetime string with milliseconds
        return datetime.strptime(incoming, "%Y-%m-%dT%H:%M:%S.%f%z")
    except ValueError:
        try:
            # If milliseconds are not present, try parsing without them
            return datetime.strptime(incoming, "%Y-%m-%dT%H:%M:%S%z")
        except ValueError:
             try:
                # try with Z
                return datetime.strptime(incoming, "%Y-%m-%dT%H:%M:%SZ")
             except ValueError:
                return None #Or raise exception


def update(configuration: dict, state: dict):
    """
    Fetches and processes billing plan data from the Guidewire Billing API.
    Handles authentication, pagination, and error handling.
    """
    log.info("Fetching billing plan data from Guidewire")

    base_url = configuration.get(GUIDEWIRE_BASE_URL)
    username = configuration.get(GUIDEWIRE_USERNAME)
    password = configuration.get(GUIDEWIRE_PASSWORD)
    api_version = configuration.get(GUIDEWIRE_API_VERSION, "v1")  # Default to "v1" if not provided

    if not base_url or not username or not password:
        log.error("Missing required configuration: base URL, username, or password")
        return  # Or raise an exception

    # --- Authentication (Basic Auth Example - Adapt as needed) ---
    auth = (username, password)

    # --- API Endpoint (Adapt based on Guidewire Docs) ---
    billing_plans_url = f"{base_url}/billingplans"  #  endpoint.

    # --- State Management (Example: Last updated timestamp) ---
    last_updated = state.get("last_updated")  #  last updated time

    try:
        page_number = 1
        while billing_plans_url:  # Handle pagination
            log.info(f"Fetching data from: {billing_plans_url}, page: {page_number}")

            # --- Make the API Request ---
            params = {'page': page_number}  # Start with page 1
            response = rq.get(billing_plans_url, auth=auth, params=params)  # Include auth and params

            response.raise_for_status()  # Raise an exception for bad status codes (4xx or 5xx)

            data = response.json()
            plans = data.get("data", [])  # Adjust based on the actual response structure

            if not plans:
                log.info("No billing plans found in this page.  Exiting pagination.")
                break  # Exit the loop if no plans are found on the current page

            for plan in plans:
                # --- Example Data Extraction (Adapt based on API response) ---
                plan_id = plan.get("id")
                attributes = plan.get("attributes", {})
                plan_name = attributes.get("planName")
                description = attributes.get("description")
                start_date_str = attributes.get("startDate")
                end_date_str = attributes.get("endDate")
                status = attributes.get("status")
                create_time_str = attributes.get("createTime")
                update_time_str = attributes.get("updateTime")
                account_id = attributes.get("account")  # Get the account object

                # Extract the account ID from the account object, if it exists
                account_id_value = account_id.get("id") if isinstance(account_id, dict) else None


                start_date = str2dt(start_date_str) if start_date_str else None
                end_date = str2dt(end_date_str) if end_date_str else None
                create_time = str2dt(create_time_str) if create_time_str else None
                update_time = str2dt(update_time_str) if update_time_str else None

                # --- State Check (if using last_updated) ---
                # if last_updated and update_time < last_updated:
                #     continue  # Skip if the plan hasn't been updated since the last sync

                yield op.upsert(
                    table="billing_plans",
                    data={
                        "id": plan_id,
                        "plan_name": plan_name,
                        "description": description,
                        "start_date": start_date,
                        "end_date": end_date,
                        "status": status,
                        "create_time": create_time,
                        "update_time": update_time,
                        "account_id": account_id_value,
                        # Add more fields as needed
                    },
                )

            # --- Update State (Example: Update last_updated) ---
            # last_updated = max(last_updated, update_time) if last_updated and update_time else update_time
            # yield op.checkpoint(state={"last_updated": last_updated})

            # --- Handle Pagination (Example: Check for a 'next' link) ---
            #  This example assumes page based pagination.  Guidewire may use different methods.
            #  You MUST consult the Guidewire API documentation for the correct pagination implementation.
            if 'links' in data and 'next' in data['links']:
                billing_plans_url = data['links']['next']  # Get the URL for the next page
                page_number += 1
            else:
                billing_plans_url = None  # No more pages
        yield op.checkpoint(state={}) #no state
    except rq.exceptions.RequestException as e:
        log.error(f"API request error: {e}")
    except ValueError as e:
        log.error(f"Error parsing JSON: {e}")
    except Exception as e:
        log.error(f"An unexpected error occurred: {e}")



connector = Connector(update=update, schema=schema)

if __name__ == "__main__":
    connector.debug()